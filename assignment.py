# -*- coding: utf-8 -*-
"""assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/192zk-NUXMwoehvsLCNO8xVDfWSCXm8iD
"""

import networkx as nx

def modularity(G, communities):
    m = G.number_of_edges()
    if m == 0:
        return 0.0
    q = 0.0
    for comm in communities:

        internal_edges = 0
        for u, v in G.edges():
            if u in comm and v in comm:
                internal_edges += 1
        e_uu = internal_edges / m
        sum_degrees = sum(G.degree(n) for n in comm)
        a_u = sum_degrees / (2 * m)
        q += e_uu - a_u ** 2
    return q

def girvan_newman_communities(G):
    original_G = G.copy()
    current_graph = G.copy()
    best_partition = list(nx.connected_components(current_graph))
    best_q = modularity(original_G, best_partition)
    q_values = [best_q]
    prev_num_components = len(best_partition)

    while current_graph.number_of_edges() > 0:

        edge_btwn = nx.edge_betweenness_centrality(current_graph)
        # Find the edge with the highest betweenness
        max_btwn = max(edge_btwn.values())
        candidates = [edge for edge, btwn in edge_btwn.items() if btwn == max_btwn]
        edge_to_remove = candidates[0]
        current_graph.remove_edge(*edge_to_remove)

        new_num_components = nx.number_connected_components(current_graph)
        if new_num_components > prev_num_components:
            partition = list(nx.connected_components(current_graph))
            q = modularity(original_G, partition)
            q_values.append(q)
            if q > best_q:
                best_q = q
                best_partition = partition
            prev_num_components = new_num_components

    return best_partition, best_q, q_values